# 任务 (详见Book_shelf_page)

## 缓存的实现

### 实现简单的下载任务

1. 无视可能发生的情况，只要能够下载就可以了。
2. 要能够加载之后显示在前台

问题:Retrofit的同步如何实现?
```java

GET("xxx")
Call<xxx> getxxxx();

//或者

GET("xxx")
XXX getxxx(); //XXX表示具体对象
```
测试，是否在添加了addRxConvert的情况下还可以使用。

问题:创建文件的时候，如果没有父目录会怎么样?

答案是会出错。

### 解决可能发生的问题

1. 首先判断该章节是否曾经被加载过

2. 判断网络是否出问题

3. 判断是否取消加载(这个需要当有下载列表的时候再判断)

问题:

2. 如何监听网络是否出现问题

详见:NetWorkManager类  ->  缺少的知识点在于不知道Android提供的各种Service的作用

### 网络中断时候的执行策略

1. 在快执行的时候首先判断是否有网。
2. 在缓存每个章节的时候判断是否有网。
3. 没有网络可能造成下载出错的情况，当下载出错的时候如何执行
4. 提供在wifi环境的提示。

## 实现下载列表

1. 首先实现UI。
2. 实现进度的显示
3. 实现加载错误，等一系列问题的显示。
4. 实现对加载的控制
5. 实现数据库的存储。

### 如何实现进度的显示

1. 从创建任务开始进行分析

当任务创建成功的时候，修改自己的状态，创建Task。但是有个问题就是当显示的时候如何显示到下载队列中。
如果下载队列没有创建呢？那么又该显示给谁。

那就假设每个下载队列的item都进行了监听，传递对应的事件给对应的item。当状态改变的时候传递给相应的item。
可以根据bookId判断传给哪个具体的数据。当下载完成的时候写入数据库。但是显示的时候并不同步。
即，只对值修改，而不对对象的值进行修改，造成的问题就是当刷新的时候，就复原了。所以说必须对对象的只进行修改。
这个的问题就在于在队列中传的对象会被多个线程读写。就造成了问题，所以说下载队列中的对象，和队列中的对象必须是不同的。
(不对，想错了。。。直接传就可以了 - -。如果我点击缓存然后再点击下载队列，会造成二次加载的问题，那就判断任务是否存在，
但是因为使用的是offer，这种方法不可行。已经加载的情况下如何判断，不需要判断，因为只有点击缓存的情况才会出现正在加载的问题
自己使用的这种模式无法判断缓存中是否存在任务)

重新思考实现逻辑

(1) 当点击的时候，改变CollBook的状态，创建Task，并将Task存储到数据库。
(2) 接受到Task之后，进行调用实现。 首先切换当前状态为正在加载。然后加载数据，当数据加载完成的时候修改当前状态，并存储
到数据库中。
(3) 打开下载列表，首先从数据库中加载Task，并显示。之后就是如何获取刷新的问题。个人想到的办法是通过RxBus进行刷新。


当打开列表的时候，首先从数据库Task。根据Task的状态，设置显示状态。
Task根据BookId,调用RxBus改变状态。


书籍的名字相同的问题。

1. 建立DownloadTaskBean表的时候，必须考虑到以下情况
   文件名相同,id不同。
   id相同，文件名不同。

所以最好的办法是使用联合主键，但是GreenDao不支持。所以采用其他的办法就是。将bookName作为主键，

但是在插入DownloadTask的时候，判断是否存在文件名相同的情况，如果不存在则直接创建。如果存在则用文件名(这个判断重要)

和id联合判断是否存在相应数据(存在则表示已在数据库中相同)，不存在的说明是新文件，让文件名+1直到不重复为止。

2. 所以之后的BookChapterBean采用BookName作为外键。(可以保证BookName是唯一的)

3. 获取数据之后，使用通过RxBus进行回调，修改数据并显示。

三次重新架构:

1. 保证Task任务的bookName不相同 (保证bookName是唯一的)

2. 解决存储问题

3. 解决网络错误问题 (之后的所有回调都是与TaskActivity通过RxBus进行交互)

4. 显示列表  (核心在于 正在下载和缓存的Task一定是在Service中的，只有暂停和错误的Task才会从数据库中加载。
那么列表首先从Service中获取正在加载的Task，并且加上数据库中暂停的列表，那么就完成了列表显示

这里的问题在于如何获取正在下载的Task，现在自己的架构无法获取正在下载的Task，所以到最后发现实现还是需要像作者的实现方式
)

5. 控制调用问题

6. 查看架构的问题

基于以上实现的步骤:

1. 实现不重复文件的判断。(BookShelfPresenter)

   又出现了个问题，在CollBookView中，只要点击后，就会改变update状态，需要改回来 - -。解决

2. 重新架构下载框架

3. 实现数据存储功能

4. 实现列表显示功能

5. 才是网络错误功能 -> 基于网络错误的列表显示功能

6. 显示成功后，才是控制的问题

7. 分析框架的问题

   (状态用的太多了，容易发生错误，需要梳理下用到的状态)
   CollBook根据点击，需要改变update状态 (主线程)

   CollBook根据启动任务下载，需要改变 update和cacheStatus状态。  (主线程)

   DownLoadTask创建，需要设置状态，并且有些状态只有到特殊情况才能改变。 (主线程)

   CollBook根据完成时候，改变 cacheStatus和cacheChapter (子线程)

   DownloadTask设置 size、status、currentChapter。  (子线程)

   网络也有好多状态。

### 2. 重新构建框架

核心在于正在加载的数据是在Service中的，暂停加载的数据是在数据库中。

在Service中保存Task队列。这样就能保证，第0个是正在下载的任务。之后都是等待的任务。
(这样的问题是，当重新打开的时候，永远是等待和正在加载的排在第一位，不符合逻辑)

第二种方式就是，Service开启的时候，加载全部的任务队列，然后TaskActivity进行获取，这样就加入到缓存队列中了。
(Service与Activity之间的交互问题 -> 当TaskActivity开启的时候Service通过RxBus返回一个Event事件，
利用Intent代替了EventBus 0 0)

决定采用第二种方式。

1. 默认在初始化的时候开启DownloadService

2. BookShelfFragment通过RxBus传递任务。

3. TaskActivity通过bind进行绑定任务

bind绑定的问题，当Bind被突然销毁时候如何解除绑定。 (这个问题没有想好)

遇到的问题:

1. 刷新数据库的时候，数据会到底部去。
2. 加载列表的文件大小有问题
3. 加载速度太快的问题。 (需要一个延时发送，当达到某个时间的时候，轮询状态并发送) (没有想到好的解决办法)
4. 文件创建过多的问题

首先感觉需要解决的是加载过快的问题，使用RxBus直接改变会不会好一点。加载过快的原因是 通过子线程加载数据然后回调到
修改主线程的DownloadTask再进行刷新。最后Service修改数据并存储。

如何进行优化:延迟加载，每次加载一个章节都进行延迟处理。 2. 优化View。只有当数据不同的时候才进行修改。

那么暂时不考虑上面的问题，之后要考虑的另一个问题是在那里存储的问题，怎样存储更加的高效。

## 第四次缓存的大修改（基本完成）

1. 布局的加载问题,如何保证数据改变之后显示的过程不卡顿的问题
2. 点击操作的问题,能够实现继续、暂停的切换

# 明天的任务

1. 下载列表的原理解析。
2. 阅读器的解析与制作